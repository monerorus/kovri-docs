# Соглашения
- Мы стремимся к полному соблюдению соглашений C++11/14; пожалуйста, соблюдайте их для вашей же пользы
- Пожалуйста, используйте стандартную библиотеку и библиотеки зависимостей, всегда когда это возможно

## Реакция на уязвимость
- Наш [Процесс реагирования на уязвимость](https://github.com/monero-project/meta/blob/master/VULNERABILITY_RESPONSE_PROCESS.md)  стимулирует оперативный поиск уязвимостей
- Мы также есть на [HackerOne](https://hackerone.com/monero)

## Стиль
1. Прочтите [Руководство по стилю C++ от Google](https://google.github.io/styleguide/cppguide.html) (в частности справку о не-форматированном стиле)
   - Если программируете на bash, прочтите [Google's Shell Style Guide](https://github.com/google/styleguide/blob/gh-pages/shell.xml)
2. Для файлов состоящих только из новой работы, выполните [clang-format](http://clang.llvm.org/docs/ClangFormat.html) с ```-style=file``` (который использует предоставленный нами [.clang-format](https://github.com/monero-project/kovri/blob/master/.clang-format))
```bash
$ cd kovri/ && clang-format -i -style=file src/path/to/my/file
```
3. Для файлов со смешанной работой (существующей и новой), выполните [clang-format](http://clang.llvm.org/docs/ClangFormat.html) выборочно только по строкам относящимся к новой работе.
   - Смотрите [vim](http://clang.llvm.org/docs/ClangFormat.html#vim-integration) и [emacs](http://clang.llvm.org/docs/ClangFormat.html#emacs-integration) документацию для примеров конфигурации сочетания клавиш для `clang-format` плагинов.
4. Выполните [cpplint](https://github.com/google/styleguide/tree/gh-pages/cpplint) (который использует предоставленные нами [CPPLINT.cfg](https://github.com/monero-project/kovri/blob/master/CPPLINT.cfg)) чтобы отловить любые проблемы пропущенные clang-format'ом
```bash
$ cd kovri/ && cpplint src/path/to/my/file && [edit file manually to apply fixes]
```

### Plugins

- Vim интеграция
  - [clang-format](http://clang.llvm.org/docs/ClangFormat.html#vim-integration)
  - [clang-format ubuntu 16.04 vim workaround](http://stackoverflow.com/questions/39490082/clang-format-not-working-under-gvim)
  - [cpplint.vim](https://github.com/vim-syntastic/syntastic/blob/master/syntax_checkers/cpp/cpplint.vim)
- Emacs интеграция
  - [clang-format](http://clang.llvm.org/docs/ClangFormat.html#emacs-integration) + [clang-format.el](https://llvm.org/svn/llvm-project/cfe/trunk/tools/clang-format/clang-format.el)
  - [flycheck-google-cpplint.el](https://github.com/flycheck/flycheck-google-cpplint)

### Поправки к предлагаемому стилю C ++ от Google

- Избегайте префикс в смешанном случае (mixed-case) ```k``` и MACRO_TYPE для всех констант
- Используйте три слеша ```/// C++ комментарии``` при документировании для Doxygen
- Старайтесь документировать всю работу в формате Doxygen по мере выполнения
- Если анонимность вызывает беспокойство, попробуйте имитировать стиль изначального автора

### Дополнительные проверки
1. [cppdep](https://github.com/rakhimov/cppdep)
   для зависимости компонентов, физической изоляции и вложенных проверок.
2. [cppcheck](https://github.com/danmar/cppcheck/) для статического анализа
   (в дополнение к Coverity).
3. [lizard](https://github.com/terryyin/lizard) для проверки сложности кода.

## Отправка вашей работы
Чтобы внести свой вклад выполните следующее:

1. Скопируйте ([Fork](https://help.github.com/articles/fork-a-repo/)) Kovri
2. Ознакомьтесь с разделом "Стиль", это го документа
3. Создайте [topic branch](https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging)
   - В настоящее время у нас нет никаких тегов, так как мы в стадии Alpha. Пока вы можете основывать свою работу в ветке master
4. Внесите изменения
   - Коммиты должны быть [атомарными](https://en.wikipedia.org/wiki/Atomic_commit#Atomic_commit_convention) когда это возможно и Различия(diffs) должны быть легко читаемы
   - Пожалуйста постарайтесь не смешивать правки форматирования и другие коммиты
5. Будьте внимательны к git-log
   - Заголовок коммита должен начинаться с класса или аспекта проекта. Например, "HTTPProxy: implement User-Agent scrubber. Fixes #193." или "Garlic: fix uninitialized padding in ElGamalBlock".
   - Комментарии к коммиту должны быть подробными по умолчанию, состоящими и короткой строки темы (50  символов максимум), пустой строки и детального пояснительного текста разбитого на абзацы - кроме случаев когда тема является достаточным и очевидным объяснением.
   - Если конкретный коммит связан с проблемой(issue), пожалуйста добавьте ссылку. Например "See #123", или "Fixes #123". Это поможет нам разрешить тикеты(tickets) при объединение(merge) в  ```master```.
   - Если конкретный коммит меняет основу (rebase) после совместной работы в pull-request, пожалуйста укажите номер pull-request в комментарии к коммиту. Например, *References #123*
6. [**Подпишите**](https://git-scm.com/book/en/v2/Git-Tools-Signing-Your-Work) ваш(и) коммит(ы) и если вы новый контрибьютор, откройте ноавй pull-request который добавит ваш PGP ключ в наш репозиторий (Смотри "Содействие")
7. Отправьте pull-request в ветку `master`
   - Содержание pull request должно содержать точное описание того, что делает исправление и предоставлять обоснование\доводы этого исправления (при необходимости). Вы должны включить ссылки на любые обсуждения, такие как другие тикеты (issues) или чаты в IRC.

## Предложения (Proposals)
Перед внесением предложения, пожалуйста просмотрите [открытые проблемы](https://github.com/monero-project/kovri/issues) на предмет существующих предложений. Если вашего предложения там нет, то [создайте новое](https://github.com/monero-project/kovri/issues/new).

Несмотря на то, что наш C4 диктует нам объединять(merge) все, мы просим вас создать предложение, по следующим причинам:

1. Предложение начинает диалог
2. Предложение показывает, что контрибьютор уважает вклад всех участников проекта
3. Предложение позволяет участнику прозрачно войти в открытое публичное обсуждение
4. Предложение сберегает время, если участник работает над похожей фукцией\проблемой
5. Предложение предотвращает катастрофы и казусы или позволяет участникам подготовится к катастрофам и казусам.

*Не* открытие предложения(proposal) *не* помешает вам внести вклад; мы объеденим(merge) ваш PR - но предложение настоятельно рекомендуется.

## TODO's
- Сделайте беглый поиск в кодовой базе ```TODO(unassigned):``` и\или возьмите тикет в работу и начните исправление!
- Если создаете TODO, назначьте его себе или напишите ```TODO(unassigned):```

## Fuzz testing

Из [справки](http://llvm.org/docs/LibFuzzer.html) : "LibFuzzer находится в активной разработке поэтому вам понадобится текущая (или покрайнее мере очень свежая) версия компилятора Clang"

Получить свежую версию clang:

```bash
$ cd ~/ && mkdir TMP_CLANG && git clone https://chromium.googlesource.com/chromium/src/tools/clang TMP_CLANG/clang
$ ./TMP_CLANG/clang/scripts/update.py
$ cd --
```

Получить libFuzzer:

```bash
$ git clone https://chromium.googlesource.com/chromium/llvm-project/llvm/lib/Fuzzer contrib/Fuzzer
```

Сборка kovri с включенным fuzz тестированием:

```bash
$ PATH="~/third_party/llvm-build/Release+Asserts/bin:$PATH" CC=clang CXX=clang++ make fuzz-tests
```

Использование (Пример для RouterInfo):

```bash
mkdir RI_CORPUS MIN_RI_CORPUS
find ~/.kovri/core/network_database/ -name "router_info*" -exec cp {} RI_CORPUS \;
./build/kovri-util fuzz --target=routerinfo -merge=1 MIN_RI_CORPUS RI_CORPUS
./build/kovri-util fuzz --target=routerinfo -jobs=2 -workers=2 MIN_RI_CORPUS
```

# Гаранития качества

Ниже представлена предполагаемя модель рабочего процесса для QA. Поскольку процесс носит линейный характер любая фаза может быть обработана отдельно при необходимости - при условии, что все фазы в итоге будут пройдены.

## Фаза 1: Базовый обзор (review)

- Просмотрите открытые проблемы в нашем [Issue Tracker](https://github.com/monero-project/kovri/issues/)
- Просмотрите наш [Процесс реагирования на уязвимость(Vulnerability Response Process)](https://github.com/anonimal/meta/blob/master/VULNERABILITY_RESPONSE_PROCESS.md)
- Весь код должен соответствовать нашим рекомендациям
- Отметьте области, которые нуждаются в улучшении (умственно или в коде)
- Создайте TODO и назначьте его, если возможно

## Фаза 2: Обзор спецификации /  Реализации / Документации кода

- Полный обзор спецификации для каждого модуля; например, Streaming, I2PControl и т.д.
  - Код должен быть в соответствии с основными частями спецификации, которые будут поддерживать тот же (или лучший) уровень анонимности, который предоставляет java I2P
  - Рефакторинг/реализация/патч, когда/где это необходимо
- Обеспечьте совместимость с C++ 11/14
  - Рассмотрите фазу 2, если необходимо
- Решите все связанные TODO
- Документируйте код настолько, насколько это возможно с встроенными комментариями и Doxygen
  - Код должен быть понятен начинающим и опытным программистам
  - Код должен помочь читателю лучше понять I2P
    - I2P очень сложен, поэтому наш код должен выступать в качестве превосходной замены документации спецификации, а не быть просто в качестве дополнения (это может быть утомительно, но очень полезно с точки зрения обслуживания и времени жизни програмного обеспечения)

## Фаза 3: Криптоанализ / Аудит безопасности

- Убедитесь, что криптография современная и правильно реализована
- Обоснуйте каждый вектор для известной эксплуатации
  - Учитывайте эти векторы при написании тестов
- Нарушьте работу Kovri всеми возможными путями
  - Исправьте то, что вы смогли поломать
- Всегда используйте надежные, хорошо написанные библиотеки, если это возможно.
  - Избегайте доморощенного, необоснованного, *Я уверен, что знаю лучше, чем сообщество* варианта кода
- Ищите 2 (или более) мнения от коллег, прежде чем переходить к следующему этапу

## Фаза 4: Bug squashing / Тесты / Профилирование

- Устранение приоритетных ошибок/проблем
- Пишите unit-tests тесты для каждого модуля
  - Запустите тесты. И еще раз
  - Полный обзор результатов испытаний. При необходимости пропатчить (patch). Рефакторинг по мере необходимости
- Убедитесь, что автоматизация работает на постоянной основе
  - valgrind, doxygen, clang-format
  - При необходимости пропатчить (patch). Рефакторинг по мере необходимости

## Фаза 5: Совещайтесь

- Консультируйтесь с коллегами и сообществом
  - Совещание должно быть публичным, через тикет, встречу и\или IRC
- Примите все отзывы и дайте вразумительный ответ
- Если это выполнено, выполните следующую фазу, иначе повторите эту фазу (или начните с предыдущей фазы)

## Фаза 6: Повторите цикл с самого начала

# [Правила поведения (22/C4.1)](http://rfc.zeromq.org/spec:22)

## Лицензия

Copyright (c) 2009-2015 Pieter Hintjens.

This Specification is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 3 of the License, or (at your option) any later version.

This Specification is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program; if not, see <http://www.gnu.org/licenses>.

## Язык

Слова "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", и "OPTIONAL" в этом документе должны быть интерпретированы как описано в RFC 2119.

## Цели

C4 означает предоставление многоразовой оптимальной модели взаимодействия для проектов с открытым исходным кодом. И имеет следующие специфичные цели:

- Максимально маштабировать и разнообразить сообщество вокруг проекта, уменьшив сложность для новых контрибьюторов и расширив модель участия с положительными отзывами;
- Освободить зависимости от ключевых лиц, выделив разные наборы навыков, чтобы в любой требуемой области существовал более широкий круг компетенций;
- Позволить проекту развиваться быстрее и точнее, увеличивая разнообразие процесса принятия решений;
- Поддерживать естественный жизненный цикл версий проекта от экспериментального до стабильного, позволяя безопасное экспериментирование, быстрый сбой и изоляцию стабильного кода;
- Уменьшить внутреннюю сложность репозиториев проекта, тем самым облегчая участие контрибьюторов и уменьшая область для ошибок; 
- Обеспечить коллективное владение проектом, что увеличивает экономический стимул для контрибьюторов и снижает риск похищения со стороны враждебных организаций.

## Дизайн

### Предварительные замечания

- Проект ДОЛЖЕН(SHALL) использовать систему управления распределенными версиями git.
- Проект ДОЛЖЕН(SHALL) быть размещен на github.com или его эквиваленте, называемом здесь «Платформа».
- Проект ДОЛЖЕН(SHALL) использовать  issue tracker платформы.
- Проекту СЛЕДУЕТ(SHOULD) иметь четко документированные рекомендации по стилю кода.
- «Участник(контрибьютор)» - это человек, который хочет предоставить патч, являющийся набором коммитов, которые решают некоторые четко определенные проблемы.
- "Сопровождающий(Maintainer)" - это человек, который объединяет(merge) патчи в проекте. Сопровождающие не являются разработчиками; их работа заключается в обеспечении соблюдения процесса.
- Участники(контрибьюторы) НЕ ДОЛЖНЫ(SHALL NOT) иметь commit доступ к репозиторию, если они не являются также Сопровождающими(Maintainers). 
- Сопровождающие(Maintainers) ДОЛЖНЫ(SHALL) иметь commit доступ к репозиторию
- Любой, без различия или дискриминации, ДОЛЖЕН(SHALL) иметь равное право стать Участником(контрибьютором) в соответствии с условиями этого контракта.

### Лицензирование и собственность

- Проект ДОЛЖЕН(SHALL) использовать лицензию на основе общего доступа, такую как GPLv3 или ее вариант (LGPL, AGPL) или MPLv2.
- Все вклады в исходный код проекта («патчи») ДОЛЖНЫ(SHALL) использовать ту же лицензию, что и проект.
- Все патчи принадлежат их авторам. Там НЕ ДОЛЖНО(SHALL NOT) быть никакого процесса назначения авторских прав.
- Авторские права в проекте ДОЛЖНЫ(SHALL) принадлежать всем его контрибьюторам.
- Каждый участник ДОЛЖЕН(SHALL) быть ответственным за идентификацию себя в списке участников проекта.

### Требования к патчу

- Сопровождающие и участники ОБЯЗАНЫ(MUST) иметь учетную запись платформы и ДОЛЖНЫ(SHOULD) использовать свои настоящие имена или известный псевдоним.
- Патч ДОЛЖЕН(SHOULD) быть минимальным и точным ответом ровно на одну идентифицированную и согласованную проблему.
- Патч ОБЯЗАН(MUST) придерживаться правил стиля кода проекта, если они определены.
- Патч ОБЯЗАН(MUST) придерживаться руководящих принципов «Эволюция общественных контрактов», определенных ниже.
- Патч НЕ ДОЛЖЕН(SHALL NOT) включать нетривиальный код из других проектов, если только контрибьютор не является изначальным автором этого кода.
- Патч ОБЯЗАН(MUST) компилироваться и проходить самотестирование проекта, по крайней мере, на основной целевой платформе.
- Комментарию коммита патча СЛЕДУЕТ(SHOULD) состоять из одной короткой (менее 50 символов) строки, суммирующей изменение, опционально сопровождаемую пустой строкой, а затем более подробным описанием.
- «Правильный патч» - это тот, который удовлетворяет вышеуказанным требованиям.

### Процесс разработки

- Изменения в проекте ДОЛЖНЫ(SHALL) регулироваться шаблоном точной идентификации проблем и применения минимальных точных решений этих проблем.
- Чтобы запросить изменения, пользователю СЛЕДУЕТ(SHOULD) зарегистрировать проблему в трее на платформе.
- Пользователю или Контрибьютору СЛЕДУЕТ(SHOULD) написать проблему, описав проблему, с которой они сталкиваются или наблюдают.
- Пользователю или контрибьютору СЛЕДУЕТ(SHOULD) стремиться к консенсусу относительно точности их наблюдения и ценности решения проблемы.
- Пользователи НЕ ДОЛЖНЫ(SHALL NOT) регистрировать запросы функций, идеи, предложения или любые решения проблем, которые явно не документированы и не доказуемы.
- Таким образом, история выпуска проекта ДОЛЖНА(SHALL) быть списком значимых проблем, регистрируемых и решаемых.
- Чтобы работать над проблемой, участник ДОЛЖЕН(SHALL) скопировать(fork) репозиторий проекта, а затем работать в своей копии репозитория.
- Чтобы отправить патч, участник ДОЛЖЕН(SHALL) создать pull request Платформы обратно в проект.
- Участник НЕ ДОЛЖЕН(SHALL NOT) вносить изменения непосредственно в проект.
- Если Платформа реализует  pull requests в качестве проблем(issues), Участник МОЖЕТ(MAY) непосредственно отправить pull request без регистрации отдельной проблемы(issue).
- Чтобы обсудить патч, люди МОГУТ(MAY) комментировать pull request платформы, commit или в любом другом месте.
- Чтобы принять или отклонить патч, Maintainer ДОЛЖЕН(SHALL) использовать интерфейс платформы.
- Сопровождающим НЕ СЛЕДУЕТ(SHOULD NOT) объединять(merge) свои собственные исправления, за исключением особых случаев, таких как невосприимчивость других Сопровождающих в течение длительного периода (более 1-2 дней).
- Сопровождающие НЕ ДОЛЖНЫ(SHALL NOT) делать оценочные суждения относительно правильных патчей.
- Сопровождающие ДОЛЖНЫ(SHALL) объединять(merge) кореектные исправления от других участников.
- Участник МОЖЕТ(MAY) отметить проблему как «Готовую» после pull request для этой проблемы.
- Пользователь, создавший проблему, ДОЛЖЕН(SHOULD) закрыть проблему после проверки исправления.
- Сопровождающим СЛЕДУЕТ(SHOULD) просить исправлять неправильные патчи и СЛЕДУЕТ(SHOULD) отклонять неправильные патчи, если Участник не отвечает конструктивно.
- Любой участник, у которого есть оценочные суждения на правильном патче, ДОЛЖЕН(SHOULD) выражать их через свои собственные патчи.
- Сопровождающие МОГУТ(MAY) вносить изменения в документацию, не являющуюся исходным кодом, непосредственно в проект.

### Создание стабильных выпусков

- Проект ДОЛЖЕН(SHALL) иметь одну ветку ("master"), которая всегда содержит последнюю версию, и которая всегда ДОЛЖНА(SHOULD) собираться без ошибок.
- Проект НЕ ДОЛЖЕН(SHALL NOT) использовать тему(topic) веток по какой-либо причине. Личные копии(fork) МОГУТ использовать тему веток.
- Чтобы сделать стабильную версию, кто-то ДОЛЖЕН(SHALL) скопировать(fork) репозиторий, скопировав его и тем самым став обслуживающим(maintainer) этого репозитория. 
- Копирование проекта для стабилизации МОЖЕТ(MAY) быть сделано в одностороннем порядке и без согласования с разработчиками проекта
- Проект стабилизации ДОЛЖЕН(SHOULD) поддерживаться таким же процессом, что и основной проект.
- Патч к проекту стабилизации, объявленный "stable", ДОЛЖЕН(SHALL) сопровождаться воспроизводимым тестовым вариантом.

### Изменение общественных контрактов

- Все публичные контракты (API или протоколы) ДОЛЖНЫ(SHALL) документироваться.
- Всем публичным контрактам СЛЕДУЕТ(SHOULD) иметь место для расширяемости и экспериментов.
- Патч, который изменяет стабильный публичный контракт, НЕ ДОЛЖЕН(SHOULD NOT) нарушать существующие приложения, если не будет преобладающего консенсуса относительно ценности этого.
- Патч, который вводит новые функции в открытый контракт, ДОЛЖЕН(SHOULD) делать это с использованием новых имен.
- Старые имена ДОЛЖНЫ(SHOULD) устаревать систематически, отмечая новые имена как "experimental", пока они не станут стабильными, а затем отмечают старые имена как "deprecated".
- Когда прошло достаточно времени, старые устаревшие имена ДОЛЖНЫ(SHOULD) быть отмечены  "legacy" и в конечном итоге удалены.
- Старые имена НЕ ДОЛЖНЫ(SHALL NOT) повторно использоваться новыми функциями.
- Когда старые имена удаляются, их реализации ДОЛЖНЫ(MUST) провоцировать исключение (утверждение), если оно используется приложениями.

### Управление проектами

- Учредители проекта ДОЛЖНЫ(SHALL) выступать в качестве Администраторов для управления составом Сопровождающих(Maintainers)
- Администраторы ДОЛЖНЫ(SHALL) обеспечить свою собственную преемственность в течении времени, продвигая наиболее эффективных Сопровождающих(Maintainers).
- Новый Котрибьютор, который делает правильный патч, ДОЛЖЕН(SHALL) быть приглашен стать Сопровождающим(Maintainer).
- Администраторы МОГУТ(MAY) удалять Сопровождающих(Maintainers), которые неактивны в течение длительного периода времени, или которые неоднократно не соблюдали строго этот процесс.
- Администраторы ДОЛЖНЫ(SHOULD) блокировать или банить «плохих актеров», которые вызывают стресс и боль у других в проекте. Это должно быть сделано после публичного обсуждения, с возможностью для всех сторон высказаться. Плохой актер - это тот, кто неоднократно игнорирует правила и культуру проекта, который бесполезно аргументирует или враждебен, или кто оскорбителен, и который не может самостоятельно исправлять свое поведение, когда его просят сделать это другие.

# Процесс управления

![Governance Process](https://getmonero.org/blog/assets/2015-year-in-review/governance-process.jpg)
